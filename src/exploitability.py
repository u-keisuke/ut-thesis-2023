def compute_exploitability(
    node, information_sets, average_strategy_profile, opponent_player, MEMO_NODE_EU
):
    """
    exploitability when opponent player chooses best response for current strategy
    """
    if node.terminal:
        return node.eu, MEMO_NODE_EU
    if node.player == opponent_player:  # choose exploitable strategy
        best_response_value = None
        best_weighted_expected_utility = (
            -float("inf") if opponent_player == 0 else float("inf")
        )  # current best value
        for action, _ in node.children.items():
            # current value of sum of reach_p * expected_utility
            current_weighted_expected_utility = 0
            current_node_expected_utility = 0
            for same_info_node in information_sets[node.player][node.information]:
                if same_info_node.children[action] in MEMO_NODE_EU:
                    expected_utility = MEMO_NODE_EU[same_info_node.children[action]]
                else:
                    expected_utility, MEMO_NODE_EU = compute_exploitability(
                        same_info_node.children[action],
                        information_sets,
                        average_strategy_profile,
                        opponent_player,
                        MEMO_NODE_EU,
                    )
                    MEMO_NODE_EU[same_info_node.children[action]] = expected_utility
                if node == same_info_node:
                    current_node_expected_utility = expected_utility
                current_weighted_expected_utility += (
                    same_info_node.true_pi_mi * expected_utility
                )

            if opponent_player == 0:
                if best_weighted_expected_utility < current_weighted_expected_utility:
                    best_weighted_expected_utility = current_weighted_expected_utility
                    best_response_value = current_node_expected_utility
            else:
                if best_weighted_expected_utility > current_weighted_expected_utility:
                    best_weighted_expected_utility = current_weighted_expected_utility
                    best_response_value = current_node_expected_utility
        return best_response_value, MEMO_NODE_EU

    else:  # use current strategy
        expected_utility = 0
        for action, child_node in node.children.items():
            p = average_strategy_profile[node.player][node.information][action]
            expected_utility_tmp, MEMO_NODE_EU = compute_exploitability(
                child_node,
                information_sets,
                average_strategy_profile,
                opponent_player,
                MEMO_NODE_EU,
            )
            expected_utility += p * expected_utility_tmp
    return expected_utility, MEMO_NODE_EU


def get_exploitability(game, average_strategy_profile):
    best_reponse_0, MEMO_NODE_EU = compute_exploitability(
        game.root,
        game.information_sets,
        average_strategy_profile,
        opponent_player=0,
        MEMO_NODE_EU={},
    )
    best_reponse_1, MEMO_NODE_EU = compute_exploitability(
        game.root,
        game.information_sets,
        average_strategy_profile,
        opponent_player=1,
        MEMO_NODE_EU={},
    )

    exploitability = best_reponse_0 + (-1) * best_reponse_1
    exploitability /= game.num_players

    return exploitability, [best_reponse_0, best_reponse_1], MEMO_NODE_EU
